(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{728:function(_,a,t){"use strict";t.r(a);var v=t(30),s=Object(v.a)({},(function(){var _=this,a=_.$createElement,t=_._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"一、整洁代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、整洁代码"}},[_._v("#")]),_._v(" 一、整洁代码")]),_._v(" "),t("h2",{attrs:{id:"二、有意义的命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、有意义的命名"}},[_._v("#")]),_._v(" 二、有意义的命名")]),_._v(" "),t("h3",{attrs:{id:"_1、名副其实"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、名副其实"}},[_._v("#")]),_._v(" 1、名副其实")]),_._v(" "),t("p",[_._v("一旦发现有更好的名称，就换掉旧的\n变量、函数或类名称应该已经答复了所有的大问题\n代码的模糊度：即上下文在代码中未被明确体现的程度")]),_._v(" "),t("h3",{attrs:{id:"_2、避免误导"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、避免误导"}},[_._v("#")]),_._v(" 2、避免误导")]),_._v(" "),t("p",[_._v("程序员必须避免留下掩盖代码本意的错误线索。应当避免使用与本意相悖的词\n以同样的方式拼写出同样的概念才是信息，拼写前后不一致就是误导\n要注意使用小写字母i和大写字母O作为变量名，看起来像“壹”和“零”")]),_._v(" "),t("h3",{attrs:{id:"_3、做有意义的区分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、做有意义的区分"}},[_._v("#")]),_._v(" 3、做有意义的区分")]),_._v(" "),t("p",[_._v("不要为了满足编译器和解释器的需求而写代码（如 a,b;虽然满足编译器和解释器，但是不方便阅读）\n同一作用范围内两样不同的东西不能重名，如果名称必须相异，那其意思也应该不同才对\n废话是另一种没意义的区分。假设你有一个Product类，如果还有一个ProductInfo或ProductData类，那它们的名称虽然不同，意思却无区别\n只要体现出有意义的区分，使用a和the这样的前缀就没错\n废话都是冗余。Variable一词记录不应当出现在变量名中，Table一词永远不应当出现在表名中")]),_._v(" "),t("h3",{attrs:{id:"_4、使用读的出来的名称-名称要是可阅读和描述的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、使用读的出来的名称-名称要是可阅读和描述的"}},[_._v("#")]),_._v(" 4、使用读的出来的名称（名称要是可阅读和描述的）")]),_._v(" "),t("h3",{attrs:{id:"_5、使用可搜索的名称"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、使用可搜索的名称"}},[_._v("#")]),_._v(" 5、使用可搜索的名称")]),_._v(" "),t("p",[_._v("单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来（能够全局搜索出来）\n名称的长短应与其作用域大小相对应")]),_._v(" "),t("h3",{attrs:{id:"_6、避免使用编码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、避免使用编码"}},[_._v("#")]),_._v(" 6、避免使用编码")]),_._v(" "),t("p",[_._v("把类型或作用域编进名称里面，徒然增加了解码的负担")]),_._v(" "),t("h3",{attrs:{id:"_7、避免思维映射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、避免思维映射"}},[_._v("#")]),_._v(" 7、避免思维映射")]),_._v(" "),t("p",[_._v("不应当让读者在脑中把你的名称翻译为他们熟知的名称\n专业程序员了解，明确是王道")]),_._v(" "),t("h3",{attrs:{id:"_8、类名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、类名"}},[_._v("#")]),_._v(" 8、类名")]),_._v(" "),t("p",[_._v("类名对象名应该是名词或者名词短语")]),_._v(" "),t("h3",{attrs:{id:"_9、方法名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9、方法名"}},[_._v("#")]),_._v(" 9、方法名")]),_._v(" "),t("p",[_._v("方法名应当是动词或动词短语。修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀\n可以考虑将相应构造器设置为private，强制使用这种命名手段")]),_._v(" "),t("h2",{attrs:{id:"三、函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、函数"}},[_._v("#")]),_._v(" 三、函数")]),_._v(" "),t("h3",{attrs:{id:"_1、短小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、短小"}},[_._v("#")]),_._v(" 1、短小")]),_._v(" "),t("p",[_._v("函数的第一规则是要短小。第二条规则是还要更短小\nif语句、else语句、while语句等，其中的代码块应该只有一行，该行大抵是一个函数调用语句\n函数不应该大到足以容纳嵌套结构，所以，函数的缩进层级不该多于一层或两层")]),_._v(" "),t("h3",{attrs:{id:"_2、只做一件事"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、只做一件事"}},[_._v("#")]),_._v(" 2、只做一件事")]),_._v(" "),t("p",[_._v("函数应该做一件事，做好这件事。只做这件事\n要判断函数是否不止做了一件事，就是看看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现\n只做一件事的函数无法被合理地切分为多个区段")]),_._v(" "),t("h3",{attrs:{id:"_3、每个函数一个抽象层级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、每个函数一个抽象层级"}},[_._v("#")]),_._v(" 3、每个函数一个抽象层级")]),_._v(" "),t("p",[_._v("要确保函数只做一件事，函数中的语句都要在同一抽象层级上\n自顶向下读代码：向下规则，让代码拥有自顶向下的阅读顺序，让每个函数后面都跟着下一抽象层级的函数")]),_._v(" "),t("h3",{attrs:{id:"_4、switch语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、switch语句"}},[_._v("#")]),_._v(" 4、switch语句")]),_._v(" "),t("p",[_._v("写出短小的switch语句很维，写出只做一件事的switch语句也很难，Switch天生要做N件事\n将switch语句埋到抽象工厂底下，不让任何人看到\n如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍")]),_._v(" "),t("h3",{attrs:{id:"_4、使用描述性的名称"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、使用描述性的名称"}},[_._v("#")]),_._v(" 4、使用描述性的名称")]),_._v(" "),t("p",[_._v("沃德原则：“如果每个例程都让你感到深合已意，那就是整洁代码”\n函数越短小，功能越集中，就越便于取个好名字\n别害怕长名称。长而具有描述性的名称，比短而令人费解的名称好。\n命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名")]),_._v(" "),t("h3",{attrs:{id:"_5、函数参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、函数参数"}},[_._v("#")]),_._v(" 5、函数参数")]),_._v(" "),t("p",[_._v("最理想的参数数量是零，有足够的理由才能用三个以上参数\n从测试角度看，参数甚至更叫人为难（需要测试用例，需要兼容所有参数可能性，如3参数，每个有4种可能；就需要4"),t("em",[_._v("4")]),_._v("4=64种测试用例）\n事件：在这种形式中，有输入参数而无输出参数，程序将函数看作一个事件，使用该参数修改系统状态\n转换：如果函数要对输入参数进行转换操作，转换结果就该体现为返回值\n标识参数：向函数传入布尔值会使方法签名立刻变得复杂起来，大声宣布函数不止做一件事\n如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了\n有可变参数的函数可能是一元、二元甚至三元，超过这个数量就可能要犯错了\n对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式")]),_._v(" "),t("h3",{attrs:{id:"_6、无副作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、无副作用"}},[_._v("#")]),_._v(" 6、无副作用")]),_._v(" "),t("p",[_._v("函数承诺只做一件事，但还是会做其他被藏起来的事，会导致古怪的时序性耦合及顺序依赖\n参数多数会被自然而希地看作是函数的输入")]),_._v(" "),t("h3",{attrs:{id:"_7、分隔指令与询问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、分隔指令与询问"}},[_._v("#")]),_._v(" 7、分隔指令与询问")]),_._v(" "),t("p",[_._v("函数要么做什么事，要么回答什么事，但二者不可得兼")]),_._v(" "),t("h3",{attrs:{id:"_8、使用异常替代返回错误码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、使用异常替代返回错误码"}},[_._v("#")]),_._v(" 8、使用异常替代返回错误码")]),_._v(" "),t("p",[_._v("从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在if语句判断中把指令当作表达式使用\ntry/catch代码块把错误处理与正常流程混为一谈，最好把try和catch代码块的主体部分抽离出来，另外形成函数（throw exception也一样）\n错误处理就是一件事，处理错误的函数不该做其他事")]),_._v(" "),t("h2",{attrs:{id:"四、注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、注解"}},[_._v("#")]),_._v(" 四、注解")]),_._v(" "),t("h3",{attrs:{id:"_1、好注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、好注释"}},[_._v("#")]),_._v(" 1、好注释")]),_._v(" "),t("ul",[t("li",[_._v("法律信息")]),_._v(" "),t("li",[_._v("提供信息的注解")]),_._v(" "),t("li",[_._v("对意图的解释：提供某个决定背后的意图")]),_._v(" "),t("li",[_._v("阐释：注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读形式")]),_._v(" "),t("li",[_._v("警示：有时，用于警告其他程序员会出现某种后果的注释也是有用的")]),_._v(" "),t("li",[_._v("TODO注释：注意要清理")]),_._v(" "),t("li",[_._v("放大：放大某种看来不合理之物的重要性")]),_._v(" "),t("li",[_._v("共API中的Javadoc")])]),_._v(" "),t("h3",{attrs:{id:"_2、坏注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、坏注释"}},[_._v("#")]),_._v(" 2、坏注释")]),_._v(" "),t("ul",[t("li",[_._v("喃喃自语")]),_._v(" "),t("li",[_._v("多余的注释")]),_._v(" "),t("li",[_._v("误导性注释")]),_._v(" "),t("li",[_._v("循规式注释")]),_._v(" "),t("li",[_._v("日志式注释")]),_._v(" "),t("li",[_._v("废话注释")]),_._v(" "),t("li",[_._v("可怕的废话")]),_._v(" "),t("li",[_._v("能用函数和变量时就别用注释")]),_._v(" "),t("li",[_._v("位置标记")]),_._v(" "),t("li",[_._v("括号后面的注释")]),_._v(" "),t("li",[_._v("归属与署名")]),_._v(" "),t("li",[_._v("注释掉的代码")]),_._v(" "),t("li",[_._v("HTML注解")]),_._v(" "),t("li",[_._v("非本地信息")]),_._v(" "),t("li",[_._v("信息过多")]),_._v(" "),t("li",[_._v("不明显的联系")]),_._v(" "),t("li",[_._v("函数头")]),_._v(" "),t("li",[_._v("非公共代码的javadoc")]),_._v(" "),t("li",[_._v("范例")])]),_._v(" "),t("h3",{attrs:{id:"五、格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、格式"}},[_._v("#")]),_._v(" 五、格式")]),_._v(" "),t("h3",{attrs:{id:"六、对象和数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、对象和数据结构"}},[_._v("#")]),_._v(" 六、对象和数据结构")]),_._v(" "),t("h3",{attrs:{id:"七、错误的处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、错误的处理"}},[_._v("#")]),_._v(" 七、错误的处理")]),_._v(" "),t("p",[_._v("注：后续都不常用 ，在这里就不一一赘述，前面一些要点都是开发中经常忽略的。例如一个类几千行 ，\n一个方法过长、代码块重复率高日常开发中需要刻意提高代码质量，不能以完成需求为目的，\n随心所欲去写，这将在后续代码维护中产生很大的麻烦。")]),_._v(" "),t("p",[_._v("代码整洁之道只是教我们怎么去写最基础的代码，若想要写出高质量，高效率的代码，还要结合设计模式，数据结构，算法等等知识，提高项目的扩展性\n、高复用性，和执行效率。")])])}),[],!1,null,null,null);a.default=s.exports}}]);